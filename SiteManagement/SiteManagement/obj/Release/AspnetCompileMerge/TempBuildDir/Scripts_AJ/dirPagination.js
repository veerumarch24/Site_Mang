!function () { function d(a, c, d) { function e(e, k) { var l = k.dirPaginate, m = l.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), n = /\|\s*itemsPerPage\s*:[^|]*/; if (null === m[2].match(n)) throw "pagination directive: the 'itemsPerPage' filter must be set."; var o = m[2].replace(n, ""), p = c(o); h(e); var q = k.paginationId || b; return d.registerInstance(q), function (h, k, m) { var n = c(m.paginationId)(h) || m.paginationId || b; d.registerInstance(n); var o = f(l, n); g(k, m, o), i(k); var q = a(k), r = j(h, m, n); d.setCurrentPageParser(n, r, h), "undefined" != typeof m.totalItems ? (d.setAsyncModeTrue(n), h.$watch(function () { return c(m.totalItems)(h) }, function (a) { 0 <= a && d.setCollectionLength(n, a) })) : h.$watchCollection(function () { return p(h) }, function (a) { a && d.setCollectionLength(n, a.length) }), q(h) } } function f(a, c) { var d, e = !!a.match(/(\|\s*itemsPerPage\s*:[^|]*:[^|]*)/); return d = c === b || e ? a : a.replace(/(\|\s*itemsPerPage\s*:[^|]*)/, "$1 : '" + c + "'") } function g(a, b, c) { a[0].hasAttribute("dir-paginate-start") || a[0].hasAttribute("data-dir-paginate-start") ? (b.$set("ngRepeatStart", c), a.eq(a.length - 1).attr("ng-repeat-end", !0)) : b.$set("ngRepeat", c) } function h(a) { angular.forEach(a, function (a) { a.nodeType === Node.ELEMENT_NODE && angular.element(a).attr("dir-paginate-no-compile", !0) }) } function i(a) { angular.forEach(a, function (a) { a.nodeType === Node.ELEMENT_NODE && angular.element(a).removeAttr("dir-paginate-no-compile") }), a.eq(0).removeAttr("dir-paginate-start").removeAttr("dir-paginate").removeAttr("data-dir-paginate-start").removeAttr("data-dir-paginate"), a.eq(a.length - 1).removeAttr("dir-paginate-end").removeAttr("data-dir-paginate-end") } function j(a, b, d) { var e; if (b.currentPage) e = c(b.currentPage); else { var f = d + "__currentPage"; a[f] = 1, e = c(f) } return e } return { terminal: !0, multiElement: !0, compile: e } } function e() { return { priority: 5e3, terminal: !0 } } function f(a) { a.put("angularUtils.directives.dirPagination.template", '<ul class="pagination" ng-if="1 < pages.length"><li ng-if="boundaryLinks" ng-class="{ disabled : pagination.current == 1 }"><a href="" ng-click="setCurrent(1)">&laquo;</a></li><li ng-if="directionLinks" ng-class="{ disabled : pagination.current == 1 }"><a href="" ng-click="setCurrent(pagination.current - 1)">&lsaquo;</a></li><li ng-repeat="pageNumber in pages track by $index" ng-class="{ active : pagination.current == pageNumber, disabled : pageNumber == \'...\' }"><a href="" ng-click="setCurrent(pageNumber)">{{ pageNumber }}</a></li><li ng-if="directionLinks" ng-class="{ disabled : pagination.current == pagination.last }"><a href="" ng-click="setCurrent(pagination.current + 1)">&rsaquo;</a></li><li ng-if="boundaryLinks"  ng-class="{ disabled : pagination.current == pagination.last }"><a href="" ng-click="setCurrent(pagination.last)">&raquo;</a></li></ul>') } function g(a, c) { function e(c, e, g) { function l(b) { o(b) && (c.pages = f(b, a.getCollectionLength(i), a.getItemsPerPage(i), k), c.pagination.current = b, n(), c.onPageChange && c.onPageChange({ newPageNumber: b })) } function m() { var b = parseInt(a.getCurrentPage(i)) || 1; c.pages = f(b, a.getCollectionLength(i), a.getItemsPerPage(i), k), c.pagination.current = b, c.pagination.last = c.pages[c.pages.length - 1], c.pagination.last < c.pagination.current ? c.setCurrent(c.pagination.last) : n() } function n() { var b = a.getCurrentPage(i), d = a.getItemsPerPage(i), e = a.getCollectionLength(i); c.range.lower = (b - 1) * d + 1, c.range.upper = Math.min(b * d, e), c.range.total = e } function o(a) { return d.test(a) && 0 < a && a <= c.pagination.last } var h = g.paginationId || b, i = c.paginationId || g.paginationId || b; if (!a.isRegistered(i) && !a.isRegistered(h)) { var j = i !== b ? " (id: " + i + ") " : " "; throw "pagination directive: the pagination controls" + j + "cannot be used without the corresponding pagination directive." } c.maxSize || (c.maxSize = 9), c.directionLinks = !angular.isDefined(g.directionLinks) || c.$parent.$eval(g.directionLinks), c.boundaryLinks = !!angular.isDefined(g.boundaryLinks) && c.$parent.$eval(g.boundaryLinks); var k = Math.max(c.maxSize, 5); c.pages = [], c.pagination = { last: 1, current: 1 }, c.range = { lower: 1, upper: 1, total: 1 }, c.$watch(function () { return (a.getCollectionLength(i) + 1) * a.getItemsPerPage(i) }, function (a) { 0 < a && m() }), c.$watch(function () { return a.getItemsPerPage(i) }, function (a, b) { a != b && "undefined" != typeof b && l(c.pagination.current) }), c.$watch(function () { return a.getCurrentPage(i) }, function (a, b) { a != b && l(a) }), c.setCurrent = function (b) { o(b) && (b = parseInt(b, 10), a.setCurrentPage(i, b)) } } function f(a, b, c, d) { var i, e = [], f = Math.ceil(b / c), h = Math.ceil(d / 2); i = a <= h ? "start" : f - h < a ? "end" : "middle"; for (var j = d < f, k = 1; k <= f && k <= d;) { var l = g(k, a, d, f), m = 2 === k && ("middle" === i || "end" === i), n = k === d - 1 && ("middle" === i || "start" === i); j && (m || n) ? e.push("...") : e.push(l), k++ } return e } function g(a, b, c, d) { var e = Math.ceil(c / 2); return a === c ? d : 1 === a ? a : c < d ? d - e < b ? d - c + a : e < b ? b - e + a : a : a } var d = /^\d+$/; return { restrict: "AE", templateUrl: function (a, b) { return b.templateUrl || c.getPath() }, scope: { maxSize: "=?", onPageChange: "&?", paginationId: "=?" }, link: e } } function h(a) { return function (c, d, e) { if ("undefined" == typeof e && (e = b), !a.isRegistered(e)) throw "pagination directive: the itemsPerPage id argument (id: " + e + ") does not match a registered pagination-id."; var f, g; return c instanceof Array ? (d = parseInt(d) || 9999999999, g = a.isAsyncMode(e) ? 0 : (a.getCurrentPage(e) - 1) * d, f = g + d, a.setItemsPerPage(e, d), c.slice(g, f)) : c } } function i() { var b, a = {}; this.registerInstance = function (c) { "undefined" == typeof a[c] && (a[c] = { asyncMode: !1 }, b = c) }, this.isRegistered = function (b) { return "undefined" != typeof a[b] }, this.getLastInstanceId = function () { return b }, this.setCurrentPageParser = function (b, c, d) { a[b].currentPageParser = c, a[b].context = d }, this.setCurrentPage = function (b, c) { a[b].currentPageParser.assign(a[b].context, c) }, this.getCurrentPage = function (b) { var c = a[b].currentPageParser; return c ? c(a[b].context) : 1 }, this.setItemsPerPage = function (b, c) { a[b].itemsPerPage = c }, this.getItemsPerPage = function (b) { return a[b].itemsPerPage }, this.setCollectionLength = function (b, c) { a[b].collectionLength = c }, this.getCollectionLength = function (b) { return a[b].collectionLength }, this.setAsyncModeTrue = function (b) { a[b].asyncMode = !0 }, this.isAsyncMode = function (b) { return a[b].asyncMode } } function j() { var a = "angularUtils.directives.dirPagination.template"; this.setPath = function (b) { a = b }, this.$get = function () { return { getPath: function () { return a } } } } var c, a = "angularUtils.directives.dirPagination", b = "__default"; try { c = angular.module(a) } catch (b) { c = angular.module(a, []) } c.directive("dirPaginate", ["$compile", "$parse", "paginationService", d]).directive("dirPaginateNoCompile", e).directive("dirPaginationControls", ["paginationService", "paginationTemplate", g]).filter("itemsPerPage", ["paginationService", h]).service("paginationService", i).provider("paginationTemplate", j).run(["$templateCache", f]) }();